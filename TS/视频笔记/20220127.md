#### 安装TS环境

`npm install typescript -g`

`npm install ts-node -g`

执行命令 `ts-node 需要运行的文件`

如无法运行安装以下两个命令

`npm install d3 @types/d3 `

`npm install @types/node `



#### ts静态类型

基础类型：略

对象类型：略

数组类型：略

类类型：

```js
class Person {...}
let tong : Person = new Person()
```

函数类型：

```js
let sayName : ()=>string = ()=>{reture '豆浆'}
```





#### 函数参数类型定义

```js
addPerson({name,age}:{name:string,age:number}){
    console.log(name,age)
}
addPerson({name:'tong',age:99})
```

#### 数组类型

联合类型数组

```js
let arr : (number|string)[] = [1,2,3,'yi'......]
```

对象类型数组

```js
// 类型别名形式 type xxx
type person = {name:string,age:number}

class person {name:string,age:number}
let tong : person[] = [......]
```

#### [类型别名和接口的区别](https://www.cnblogs.com/liuzhenwei/p/12530928.html)

```js
// 类型别名可以这样
type tong = string
// 接口必须以这样的键值对
interface tong {
    name:string,
    sayName():string
}
```

#### ts类的概念和使用

```js
class Person {
    sayName(){
        console.log('我是人类')
    }
    ...
}
```

**类的继承 extends 关键字**

```js
class Tong extends Person {
    ...
}
```

**类的重写，相同方法名会覆盖父类方法 使用 super 关键字可以重新指向父类方法**

```js
class Tong extends Person {
    sayName(){
        console.log('我是Tong')
        super.sayName()
    }
    ...
}
```

**类的访问类型**

- public 默认值 允许属性或方法在类的内外部被调用
- private 只允许在类的内部被调用
- protected 允许在类和继承的子类中的内部调用

```js
class Person {
    public name:string;
    private name2:string;
    protected name3：string;
}
```

**类的构造函数**

构造函数就是在类被初始化的时候，自动执行的一个方法 ，我们希望在new出对象的时候，直接通过传递参数的形式给属性赋值，这就需要关键字 `constructor `

```js
class Person{
    public name :string ;
    constructor(name:string){
        this.name=name
    }

}
```

类继承的构造函数，在子类中使用构造函数必需要调用`super()` ，如父类需要传参可在此处传递

```js
class Person{
    constructor( name:string){}
}
class Tong extends Person{
    constructor( age:number){
        super('tong')
    }
}

class Person2{}
class Jenny extends Person2{
    constructor(public age:number){
        super()
    }
}
```



**类的getter、setter、static、readonly**

利用getter和setter来访问和修改 private类型的属性

```js
class Person {
    constructor(private age:number){}
    // 注意 getAge不是方法 而是get关键字的属性
    get getAge(){
        return this.age + 100
    }
    // 同上
    set setAge(age){
        this.age = age
    }
}
let tong = new Person(99)
tong.setAge = 99
console.log(tong.getAge)
```

static不通过new 关键字就可以使用的静态修饰符

```js
class Girl {
  static sayLove() {
    return "I Love you";
  }
}
console.log(Girl.sayLove());
```

readonly只读属性 初始化赋值后不可再修改属性

```js
class Person {
    public readonly name :string;
    constructor(_name:string ){
        this.name = _name;
    }
}
let tong = new Person('托尼')
tong.name = '珍妮' // 报错 无法分配到 "name" ，因为它是只读属性。 
```

